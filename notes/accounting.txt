Steps accounting needs to take for program accounting.
1. Generate predefined variables, types and structures; parse user defined structures.
2. Generate predefined functions and parse user defined functions.
3. Account each function individually.
    1. Verify and map all sub-scopes.
    2. Record all offsets.
    3. Record and validate all variables.
    4. Validate all function calls.
4. Find the main function and mark it.

How to account layered scopes?
    - Treat each scope like layers of a stack.
        - Each push onto the stack is the name of the new scope.

How to account function IO?
    - All variables in a function are normal variables.
      There is no distinction between inputs, outputs and body variables.
      All variables are either predefined or body variables.
    - Variables inside the input or output arguments are just variable declarations that happen to be where function io ends up.

How to translate structure members to cells?
    - Map out all variables in a straight line of cells.

Accounting is translating the grammar into the final program blueprint? (Not the byte code itself, the blueprint for the byte code.)
I can create the cells in the accounter and generate offsets in the generator.
In order for functions to be able to accept any type, a walkthrough of all statements is necessary to generate every necessary function.
    Also, variables and members can be validated while searching through function calls.

Maybe a separate stage for expanding out definitions is required.
